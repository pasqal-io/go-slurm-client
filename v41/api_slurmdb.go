/*
Slurm REST API

API to access and control Slurm

API version: Slurm-24.05.8&openapi/slurmctld&openapi/slurmdbd
Contact: sales@schedmd.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SlurmdbAPIService SlurmdbAPI service
type SlurmdbAPIService service

type ApiSlurmdbV0041DeleteAccountRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	accountName string
}

func (r ApiSlurmdbV0041DeleteAccountRequest) Execute() (*SlurmdbV0041DeleteAccount200Response, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteAccountExecute(r)
}

/*
SlurmdbV0041DeleteAccount Delete account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return ApiSlurmdbV0041DeleteAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAccount(ctx context.Context, accountName string) ApiSlurmdbV0041DeleteAccountRequest {
	return ApiSlurmdbV0041DeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return SlurmdbV0041DeleteAccount200Response
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAccountExecute(r ApiSlurmdbV0041DeleteAccountRequest) (*SlurmdbV0041DeleteAccount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SlurmdbV0041DeleteAccount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v SlurmdbV0041DeleteAccount200Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0041DeleteAssociationRequest) Account(account string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0041DeleteAssociationRequest) Cluster(cluster string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041DeleteAssociationRequest) DefaultQos(defaultQos string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041DeleteAssociationRequest) Format(format string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0041DeleteAssociationRequest) Id(id string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.id = &id
	return r
}

// Filter to only defaults
func (r ApiSlurmdbV0041DeleteAssociationRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0041DeleteAssociationRequest) ParentAccount(parentAccount string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0041DeleteAssociationRequest) Partition(partition string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041DeleteAssociationRequest) Qos(qos string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r ApiSlurmdbV0041DeleteAssociationRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r ApiSlurmdbV0041DeleteAssociationRequest) UsageStart(usageStart string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0041DeleteAssociationRequest) User(user string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.user = &user
	return r
}

// Include usage
func (r ApiSlurmdbV0041DeleteAssociationRequest) WithUsage(withUsage string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted associations
func (r ApiSlurmdbV0041DeleteAssociationRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include a raw qos or delta_qos
func (r ApiSlurmdbV0041DeleteAssociationRequest) WithRawQos(withRawQos string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.withRawQos = &withRawQos
	return r
}

// Include sub acct information
func (r ApiSlurmdbV0041DeleteAssociationRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// Exclude parent id/name
func (r ApiSlurmdbV0041DeleteAssociationRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// Exclude limits from parents
func (r ApiSlurmdbV0041DeleteAssociationRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0041DeleteAssociationRequest) Execute() (*V0041OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteAssociationExecute(r)
}

/*
SlurmdbV0041DeleteAssociation Delete association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041DeleteAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAssociation(ctx context.Context) ApiSlurmdbV0041DeleteAssociationRequest {
	return ApiSlurmdbV0041DeleteAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAssociationExecute(r ApiSlurmdbV0041DeleteAssociationRequest) (*V0041OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "form", "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "form", "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "form", "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAssocsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteAssociationsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) Account(account string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) Cluster(cluster string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) DefaultQos(defaultQos string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041DeleteAssociationsRequest) Format(format string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) Id(id string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.id = &id
	return r
}

// Filter to only defaults
func (r ApiSlurmdbV0041DeleteAssociationsRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0041DeleteAssociationsRequest) ParentAccount(parentAccount string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) Partition(partition string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) Qos(qos string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r ApiSlurmdbV0041DeleteAssociationsRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r ApiSlurmdbV0041DeleteAssociationsRequest) UsageStart(usageStart string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) User(user string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.user = &user
	return r
}

// Include usage
func (r ApiSlurmdbV0041DeleteAssociationsRequest) WithUsage(withUsage string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted associations
func (r ApiSlurmdbV0041DeleteAssociationsRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include a raw qos or delta_qos
func (r ApiSlurmdbV0041DeleteAssociationsRequest) WithRawQos(withRawQos string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.withRawQos = &withRawQos
	return r
}

// Include sub acct information
func (r ApiSlurmdbV0041DeleteAssociationsRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// Exclude parent id/name
func (r ApiSlurmdbV0041DeleteAssociationsRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// Exclude limits from parents
func (r ApiSlurmdbV0041DeleteAssociationsRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0041DeleteAssociationsRequest) Execute() (*V0041OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteAssociationsExecute(r)
}

/*
SlurmdbV0041DeleteAssociations Delete associations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041DeleteAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAssociations(ctx context.Context) ApiSlurmdbV0041DeleteAssociationsRequest {
	return ApiSlurmdbV0041DeleteAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAssociationsExecute(r ApiSlurmdbV0041DeleteAssociationsRequest) (*V0041OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "form", "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "form", "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "form", "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAssocsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteClusterRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

// Type of machine
func (r ApiSlurmdbV0041DeleteClusterRequest) Classification(classification string) ApiSlurmdbV0041DeleteClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0041DeleteClusterRequest) Cluster(cluster string) ApiSlurmdbV0041DeleteClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r ApiSlurmdbV0041DeleteClusterRequest) Federation(federation string) ApiSlurmdbV0041DeleteClusterRequest {
	r.federation = &federation
	return r
}

// Query flags
func (r ApiSlurmdbV0041DeleteClusterRequest) Flags(flags string) ApiSlurmdbV0041DeleteClusterRequest {
	r.flags = &flags
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041DeleteClusterRequest) Format(format string) ApiSlurmdbV0041DeleteClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r ApiSlurmdbV0041DeleteClusterRequest) RpcVersion(rpcVersion string) ApiSlurmdbV0041DeleteClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end (UNIX timestamp)
func (r ApiSlurmdbV0041DeleteClusterRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041DeleteClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r ApiSlurmdbV0041DeleteClusterRequest) UsageStart(usageStart string) ApiSlurmdbV0041DeleteClusterRequest {
	r.usageStart = &usageStart
	return r
}

// Include deleted clusters
func (r ApiSlurmdbV0041DeleteClusterRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041DeleteClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include usage
func (r ApiSlurmdbV0041DeleteClusterRequest) WithUsage(withUsage string) ApiSlurmdbV0041DeleteClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r ApiSlurmdbV0041DeleteClusterRequest) Execute() (*SlurmdbV0041DeleteCluster200Response, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteClusterExecute(r)
}

/*
SlurmdbV0041DeleteCluster Delete cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return ApiSlurmdbV0041DeleteClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteCluster(ctx context.Context, clusterName string) ApiSlurmdbV0041DeleteClusterRequest {
	return ApiSlurmdbV0041DeleteClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return SlurmdbV0041DeleteCluster200Response
func (a *SlurmdbAPIService) SlurmdbV0041DeleteClusterExecute(r ApiSlurmdbV0041DeleteClusterRequest) (*SlurmdbV0041DeleteCluster200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SlurmdbV0041DeleteCluster200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "form", "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v SlurmdbV0041DeleteCluster200Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteSingleQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	qos string
}

func (r ApiSlurmdbV0041DeleteSingleQosRequest) Execute() (*SlurmdbV0041DeleteSingleQos200Response, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteSingleQosExecute(r)
}

/*
SlurmdbV0041DeleteSingleQos Delete QOS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return ApiSlurmdbV0041DeleteSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteSingleQos(ctx context.Context, qos string) ApiSlurmdbV0041DeleteSingleQosRequest {
	return ApiSlurmdbV0041DeleteSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return SlurmdbV0041DeleteSingleQos200Response
func (a *SlurmdbAPIService) SlurmdbV0041DeleteSingleQosExecute(r ApiSlurmdbV0041DeleteSingleQosRequest) (*SlurmdbV0041DeleteSingleQos200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SlurmdbV0041DeleteSingleQos200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v SlurmdbV0041DeleteSingleQos200Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteUserRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	name string
}

func (r ApiSlurmdbV0041DeleteUserRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteUserExecute(r)
}

/*
SlurmdbV0041DeleteUser Delete user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return ApiSlurmdbV0041DeleteUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteUser(ctx context.Context, name string) ApiSlurmdbV0041DeleteUserRequest {
	return ApiSlurmdbV0041DeleteUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteUserExecute(r ApiSlurmdbV0041DeleteUserRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteWckeyRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	id string
}

func (r ApiSlurmdbV0041DeleteWckeyRequest) Execute() (*SlurmdbV0041DeleteWckey200Response, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteWckeyExecute(r)
}

/*
SlurmdbV0041DeleteWckey Delete wckey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id wckey id
 @return ApiSlurmdbV0041DeleteWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteWckey(ctx context.Context, id string) ApiSlurmdbV0041DeleteWckeyRequest {
	return ApiSlurmdbV0041DeleteWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SlurmdbV0041DeleteWckey200Response
func (a *SlurmdbAPIService) SlurmdbV0041DeleteWckeyExecute(r ApiSlurmdbV0041DeleteWckeyRequest) (*SlurmdbV0041DeleteWckey200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SlurmdbV0041DeleteWckey200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v SlurmdbV0041DeleteWckey200Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetAccountRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	accountName string
	withAssocs *string
	withCoords *string
	withDeleted *string
}

// Include associations
func (r ApiSlurmdbV0041GetAccountRequest) WithAssocs(withAssocs string) ApiSlurmdbV0041GetAccountRequest {
	r.withAssocs = &withAssocs
	return r
}

// Include coordinators
func (r ApiSlurmdbV0041GetAccountRequest) WithCoords(withCoords string) ApiSlurmdbV0041GetAccountRequest {
	r.withCoords = &withCoords
	return r
}

// Include deleted
func (r ApiSlurmdbV0041GetAccountRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetAccountRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0041GetAccountRequest) Execute() (*V0041OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetAccountExecute(r)
}

/*
SlurmdbV0041GetAccount Get account info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return ApiSlurmdbV0041GetAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetAccount(ctx context.Context, accountName string) ApiSlurmdbV0041GetAccountRequest {
	return ApiSlurmdbV0041GetAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0041OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetAccountExecute(r ApiSlurmdbV0041GetAccountRequest) (*V0041OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAccountsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetAccountsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	description *string
	dELETED *string
	withAssociations *string
	withCoordinators *string
	noUsersAreCoords *string
	usersAreCoords *string
}

// CSV description list
func (r ApiSlurmdbV0041GetAccountsRequest) Description(description string) ApiSlurmdbV0041GetAccountsRequest {
	r.description = &description
	return r
}

// include deleted associations
func (r ApiSlurmdbV0041GetAccountsRequest) DELETED(dELETED string) ApiSlurmdbV0041GetAccountsRequest {
	r.dELETED = &dELETED
	return r
}

// query includes associations
func (r ApiSlurmdbV0041GetAccountsRequest) WithAssociations(withAssociations string) ApiSlurmdbV0041GetAccountsRequest {
	r.withAssociations = &withAssociations
	return r
}

// query includes coordinators
func (r ApiSlurmdbV0041GetAccountsRequest) WithCoordinators(withCoordinators string) ApiSlurmdbV0041GetAccountsRequest {
	r.withCoordinators = &withCoordinators
	return r
}

// remove users as coordinators
func (r ApiSlurmdbV0041GetAccountsRequest) NoUsersAreCoords(noUsersAreCoords string) ApiSlurmdbV0041GetAccountsRequest {
	r.noUsersAreCoords = &noUsersAreCoords
	return r
}

// users are coordinators
func (r ApiSlurmdbV0041GetAccountsRequest) UsersAreCoords(usersAreCoords string) ApiSlurmdbV0041GetAccountsRequest {
	r.usersAreCoords = &usersAreCoords
	return r
}

func (r ApiSlurmdbV0041GetAccountsRequest) Execute() (*V0041OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetAccountsExecute(r)
}

/*
SlurmdbV0041GetAccounts Get account list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetAccounts(ctx context.Context) ApiSlurmdbV0041GetAccountsRequest {
	return ApiSlurmdbV0041GetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetAccountsExecute(r ApiSlurmdbV0041GetAccountsRequest) (*V0041OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/accounts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.dELETED != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DELETED", r.dELETED, "form", "")
	}
	if r.withAssociations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "WithAssociations", r.withAssociations, "form", "")
	}
	if r.withCoordinators != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "WithCoordinators", r.withCoordinators, "form", "")
	}
	if r.noUsersAreCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NoUsersAreCoords", r.noUsersAreCoords, "form", "")
	}
	if r.usersAreCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UsersAreCoords", r.usersAreCoords, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAccountsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0041GetAssociationRequest) Account(account string) ApiSlurmdbV0041GetAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0041GetAssociationRequest) Cluster(cluster string) ApiSlurmdbV0041GetAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041GetAssociationRequest) DefaultQos(defaultQos string) ApiSlurmdbV0041GetAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041GetAssociationRequest) Format(format string) ApiSlurmdbV0041GetAssociationRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0041GetAssociationRequest) Id(id string) ApiSlurmdbV0041GetAssociationRequest {
	r.id = &id
	return r
}

// Filter to only defaults
func (r ApiSlurmdbV0041GetAssociationRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0041GetAssociationRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0041GetAssociationRequest) ParentAccount(parentAccount string) ApiSlurmdbV0041GetAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0041GetAssociationRequest) Partition(partition string) ApiSlurmdbV0041GetAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041GetAssociationRequest) Qos(qos string) ApiSlurmdbV0041GetAssociationRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r ApiSlurmdbV0041GetAssociationRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041GetAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r ApiSlurmdbV0041GetAssociationRequest) UsageStart(usageStart string) ApiSlurmdbV0041GetAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0041GetAssociationRequest) User(user string) ApiSlurmdbV0041GetAssociationRequest {
	r.user = &user
	return r
}

// Include usage
func (r ApiSlurmdbV0041GetAssociationRequest) WithUsage(withUsage string) ApiSlurmdbV0041GetAssociationRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted associations
func (r ApiSlurmdbV0041GetAssociationRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetAssociationRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include a raw qos or delta_qos
func (r ApiSlurmdbV0041GetAssociationRequest) WithRawQos(withRawQos string) ApiSlurmdbV0041GetAssociationRequest {
	r.withRawQos = &withRawQos
	return r
}

// Include sub acct information
func (r ApiSlurmdbV0041GetAssociationRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0041GetAssociationRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// Exclude parent id/name
func (r ApiSlurmdbV0041GetAssociationRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0041GetAssociationRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// Exclude limits from parents
func (r ApiSlurmdbV0041GetAssociationRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0041GetAssociationRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0041GetAssociationRequest) Execute() (*V0041OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetAssociationExecute(r)
}

/*
SlurmdbV0041GetAssociation Get association info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetAssociation(ctx context.Context) ApiSlurmdbV0041GetAssociationRequest {
	return ApiSlurmdbV0041GetAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetAssociationExecute(r ApiSlurmdbV0041GetAssociationRequest) (*V0041OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "form", "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "form", "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "form", "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetAssociationsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0041GetAssociationsRequest) Account(account string) ApiSlurmdbV0041GetAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0041GetAssociationsRequest) Cluster(cluster string) ApiSlurmdbV0041GetAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041GetAssociationsRequest) DefaultQos(defaultQos string) ApiSlurmdbV0041GetAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041GetAssociationsRequest) Format(format string) ApiSlurmdbV0041GetAssociationsRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0041GetAssociationsRequest) Id(id string) ApiSlurmdbV0041GetAssociationsRequest {
	r.id = &id
	return r
}

// Filter to only defaults
func (r ApiSlurmdbV0041GetAssociationsRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0041GetAssociationsRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0041GetAssociationsRequest) ParentAccount(parentAccount string) ApiSlurmdbV0041GetAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0041GetAssociationsRequest) Partition(partition string) ApiSlurmdbV0041GetAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041GetAssociationsRequest) Qos(qos string) ApiSlurmdbV0041GetAssociationsRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r ApiSlurmdbV0041GetAssociationsRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041GetAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r ApiSlurmdbV0041GetAssociationsRequest) UsageStart(usageStart string) ApiSlurmdbV0041GetAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0041GetAssociationsRequest) User(user string) ApiSlurmdbV0041GetAssociationsRequest {
	r.user = &user
	return r
}

// Include usage
func (r ApiSlurmdbV0041GetAssociationsRequest) WithUsage(withUsage string) ApiSlurmdbV0041GetAssociationsRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted associations
func (r ApiSlurmdbV0041GetAssociationsRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetAssociationsRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include a raw qos or delta_qos
func (r ApiSlurmdbV0041GetAssociationsRequest) WithRawQos(withRawQos string) ApiSlurmdbV0041GetAssociationsRequest {
	r.withRawQos = &withRawQos
	return r
}

// Include sub acct information
func (r ApiSlurmdbV0041GetAssociationsRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0041GetAssociationsRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// Exclude parent id/name
func (r ApiSlurmdbV0041GetAssociationsRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0041GetAssociationsRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// Exclude limits from parents
func (r ApiSlurmdbV0041GetAssociationsRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0041GetAssociationsRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0041GetAssociationsRequest) Execute() (*V0041OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetAssociationsExecute(r)
}

/*
SlurmdbV0041GetAssociations Get association list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetAssociations(ctx context.Context) ApiSlurmdbV0041GetAssociationsRequest {
	return ApiSlurmdbV0041GetAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetAssociationsExecute(r ApiSlurmdbV0041GetAssociationsRequest) (*V0041OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "form", "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "form", "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "form", "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetClusterRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

// Type of machine
func (r ApiSlurmdbV0041GetClusterRequest) Classification(classification string) ApiSlurmdbV0041GetClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0041GetClusterRequest) Cluster(cluster string) ApiSlurmdbV0041GetClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r ApiSlurmdbV0041GetClusterRequest) Federation(federation string) ApiSlurmdbV0041GetClusterRequest {
	r.federation = &federation
	return r
}

// Query flags
func (r ApiSlurmdbV0041GetClusterRequest) Flags(flags string) ApiSlurmdbV0041GetClusterRequest {
	r.flags = &flags
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041GetClusterRequest) Format(format string) ApiSlurmdbV0041GetClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r ApiSlurmdbV0041GetClusterRequest) RpcVersion(rpcVersion string) ApiSlurmdbV0041GetClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end (UNIX timestamp)
func (r ApiSlurmdbV0041GetClusterRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041GetClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r ApiSlurmdbV0041GetClusterRequest) UsageStart(usageStart string) ApiSlurmdbV0041GetClusterRequest {
	r.usageStart = &usageStart
	return r
}

// Include deleted clusters
func (r ApiSlurmdbV0041GetClusterRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include usage
func (r ApiSlurmdbV0041GetClusterRequest) WithUsage(withUsage string) ApiSlurmdbV0041GetClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r ApiSlurmdbV0041GetClusterRequest) Execute() (*V0041OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetClusterExecute(r)
}

/*
SlurmdbV0041GetCluster Get cluster info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return ApiSlurmdbV0041GetClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetCluster(ctx context.Context, clusterName string) ApiSlurmdbV0041GetClusterRequest {
	return ApiSlurmdbV0041GetClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0041OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0041GetClusterExecute(r ApiSlurmdbV0041GetClusterRequest) (*V0041OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "form", "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiClustersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetClustersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	updateTime *string
}

// Filter reservations since update timestamp
func (r ApiSlurmdbV0041GetClustersRequest) UpdateTime(updateTime string) ApiSlurmdbV0041GetClustersRequest {
	r.updateTime = &updateTime
	return r
}

func (r ApiSlurmdbV0041GetClustersRequest) Execute() (*V0041OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetClustersExecute(r)
}

/*
SlurmdbV0041GetClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetClusters(ctx context.Context) ApiSlurmdbV0041GetClustersRequest {
	return ApiSlurmdbV0041GetClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0041GetClustersExecute(r ApiSlurmdbV0041GetClustersRequest) (*V0041OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiClustersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetConfigRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
}

func (r ApiSlurmdbV0041GetConfigRequest) Execute() (*V0041OpenapiSlurmdbdConfigResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetConfigExecute(r)
}

/*
SlurmdbV0041GetConfig Dump all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetConfig(ctx context.Context) ApiSlurmdbV0041GetConfigRequest {
	return ApiSlurmdbV0041GetConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdConfigResp
func (a *SlurmdbAPIService) SlurmdbV0041GetConfigExecute(r ApiSlurmdbV0041GetConfigRequest) (*V0041OpenapiSlurmdbdConfigResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdConfigResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdConfigResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetDiagRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
}

func (r ApiSlurmdbV0041GetDiagRequest) Execute() (*SlurmdbV0041GetDiag200Response, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetDiagExecute(r)
}

/*
SlurmdbV0041GetDiag Get slurmdb diagnostics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetDiagRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetDiag(ctx context.Context) ApiSlurmdbV0041GetDiagRequest {
	return ApiSlurmdbV0041GetDiagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SlurmdbV0041GetDiag200Response
func (a *SlurmdbAPIService) SlurmdbV0041GetDiagExecute(r ApiSlurmdbV0041GetDiagRequest) (*SlurmdbV0041GetDiag200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SlurmdbV0041GetDiag200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetDiag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/diag/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v SlurmdbV0041GetDiag200Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetInstanceRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	extra *string
	format *string
	instanceId *string
	instanceType *string
	nodeList *string
	timeEnd *string
	timeStart *string
}

// CSV clusters list
func (r ApiSlurmdbV0041GetInstanceRequest) Cluster(cluster string) ApiSlurmdbV0041GetInstanceRequest {
	r.cluster = &cluster
	return r
}

// CSV extra list
func (r ApiSlurmdbV0041GetInstanceRequest) Extra(extra string) ApiSlurmdbV0041GetInstanceRequest {
	r.extra = &extra
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041GetInstanceRequest) Format(format string) ApiSlurmdbV0041GetInstanceRequest {
	r.format = &format
	return r
}

// CSV instance_id list
func (r ApiSlurmdbV0041GetInstanceRequest) InstanceId(instanceId string) ApiSlurmdbV0041GetInstanceRequest {
	r.instanceId = &instanceId
	return r
}

// CSV instance_type list
func (r ApiSlurmdbV0041GetInstanceRequest) InstanceType(instanceType string) ApiSlurmdbV0041GetInstanceRequest {
	r.instanceType = &instanceType
	return r
}

// Ranged node string
func (r ApiSlurmdbV0041GetInstanceRequest) NodeList(nodeList string) ApiSlurmdbV0041GetInstanceRequest {
	r.nodeList = &nodeList
	return r
}

// Time end (UNIX timestamp)
func (r ApiSlurmdbV0041GetInstanceRequest) TimeEnd(timeEnd string) ApiSlurmdbV0041GetInstanceRequest {
	r.timeEnd = &timeEnd
	return r
}

// Time start (UNIX timestamp)
func (r ApiSlurmdbV0041GetInstanceRequest) TimeStart(timeStart string) ApiSlurmdbV0041GetInstanceRequest {
	r.timeStart = &timeStart
	return r
}

func (r ApiSlurmdbV0041GetInstanceRequest) Execute() (*V0041OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetInstanceExecute(r)
}

/*
SlurmdbV0041GetInstance Get instance info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetInstanceRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetInstance(ctx context.Context) ApiSlurmdbV0041GetInstanceRequest {
	return ApiSlurmdbV0041GetInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0041GetInstanceExecute(r ApiSlurmdbV0041GetInstanceRequest) (*V0041OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/instance/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "form", "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "form", "")
	}
	if r.nodeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_list", r.nodeList, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiInstancesResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetInstancesRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	extra *string
	format *string
	instanceId *string
	instanceType *string
	nodeList *string
	timeEnd *string
	timeStart *string
}

// CSV clusters list
func (r ApiSlurmdbV0041GetInstancesRequest) Cluster(cluster string) ApiSlurmdbV0041GetInstancesRequest {
	r.cluster = &cluster
	return r
}

// CSV extra list
func (r ApiSlurmdbV0041GetInstancesRequest) Extra(extra string) ApiSlurmdbV0041GetInstancesRequest {
	r.extra = &extra
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041GetInstancesRequest) Format(format string) ApiSlurmdbV0041GetInstancesRequest {
	r.format = &format
	return r
}

// CSV instance_id list
func (r ApiSlurmdbV0041GetInstancesRequest) InstanceId(instanceId string) ApiSlurmdbV0041GetInstancesRequest {
	r.instanceId = &instanceId
	return r
}

// CSV instance_type list
func (r ApiSlurmdbV0041GetInstancesRequest) InstanceType(instanceType string) ApiSlurmdbV0041GetInstancesRequest {
	r.instanceType = &instanceType
	return r
}

// Ranged node string
func (r ApiSlurmdbV0041GetInstancesRequest) NodeList(nodeList string) ApiSlurmdbV0041GetInstancesRequest {
	r.nodeList = &nodeList
	return r
}

// Time end (UNIX timestamp)
func (r ApiSlurmdbV0041GetInstancesRequest) TimeEnd(timeEnd string) ApiSlurmdbV0041GetInstancesRequest {
	r.timeEnd = &timeEnd
	return r
}

// Time start (UNIX timestamp)
func (r ApiSlurmdbV0041GetInstancesRequest) TimeStart(timeStart string) ApiSlurmdbV0041GetInstancesRequest {
	r.timeStart = &timeStart
	return r
}

func (r ApiSlurmdbV0041GetInstancesRequest) Execute() (*V0041OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetInstancesExecute(r)
}

/*
SlurmdbV0041GetInstances Get instance list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetInstancesRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetInstances(ctx context.Context) ApiSlurmdbV0041GetInstancesRequest {
	return ApiSlurmdbV0041GetInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0041GetInstancesExecute(r ApiSlurmdbV0041GetInstancesRequest) (*V0041OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/instances/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "form", "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "form", "")
	}
	if r.nodeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_list", r.nodeList, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiInstancesResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetJobRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	jobId string
}

func (r ApiSlurmdbV0041GetJobRequest) Execute() (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetJobExecute(r)
}

/*
SlurmdbV0041GetJob Get job info

This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId Job id
 @return ApiSlurmdbV0041GetJobRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetJob(ctx context.Context, jobId string) ApiSlurmdbV0041GetJobRequest {
	return ApiSlurmdbV0041GetJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetJobExecute(r ApiSlurmdbV0041GetJobRequest) (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/job/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdJobsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetJobsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	association *string
	cluster *string
	constraints *string
	schedulerUnset *string
	scheduledOnSubmit *string
	scheduledByMain *string
	scheduledByBackfill *string
	jobStarted *string
	exitCode *string
	showDuplicates *string
	skipSteps *string
	disableTruncateUsageTime *string
	wholeHetjob *string
	disableWholeHetjob *string
	disableWaitForResult *string
	usageTimeAsSubmitTime *string
	showBatchScript *string
	showJobEnvironment *string
	format *string
	groups *string
	jobName *string
	partition *string
	qos *string
	reason *string
	reservation *string
	reservationId *string
	state *string
	step *string
	endTime *string
	startTime *string
	node *string
	users *string
	wckey *string
}

// CSV account list
func (r ApiSlurmdbV0041GetJobsRequest) Account(account string) ApiSlurmdbV0041GetJobsRequest {
	r.account = &account
	return r
}

// CSV association list
func (r ApiSlurmdbV0041GetJobsRequest) Association(association string) ApiSlurmdbV0041GetJobsRequest {
	r.association = &association
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0041GetJobsRequest) Cluster(cluster string) ApiSlurmdbV0041GetJobsRequest {
	r.cluster = &cluster
	return r
}

// CSV constraint list
func (r ApiSlurmdbV0041GetJobsRequest) Constraints(constraints string) ApiSlurmdbV0041GetJobsRequest {
	r.constraints = &constraints
	return r
}

// Schedule bits not set
func (r ApiSlurmdbV0041GetJobsRequest) SchedulerUnset(schedulerUnset string) ApiSlurmdbV0041GetJobsRequest {
	r.schedulerUnset = &schedulerUnset
	return r
}

// Job was started on submit
func (r ApiSlurmdbV0041GetJobsRequest) ScheduledOnSubmit(scheduledOnSubmit string) ApiSlurmdbV0041GetJobsRequest {
	r.scheduledOnSubmit = &scheduledOnSubmit
	return r
}

// Job was started from main scheduler
func (r ApiSlurmdbV0041GetJobsRequest) ScheduledByMain(scheduledByMain string) ApiSlurmdbV0041GetJobsRequest {
	r.scheduledByMain = &scheduledByMain
	return r
}

// Job was started from backfill
func (r ApiSlurmdbV0041GetJobsRequest) ScheduledByBackfill(scheduledByBackfill string) ApiSlurmdbV0041GetJobsRequest {
	r.scheduledByBackfill = &scheduledByBackfill
	return r
}

// Job start RPC was received
func (r ApiSlurmdbV0041GetJobsRequest) JobStarted(jobStarted string) ApiSlurmdbV0041GetJobsRequest {
	r.jobStarted = &jobStarted
	return r
}

// Job exit code (numeric)
func (r ApiSlurmdbV0041GetJobsRequest) ExitCode(exitCode string) ApiSlurmdbV0041GetJobsRequest {
	r.exitCode = &exitCode
	return r
}

// Include duplicate job entries
func (r ApiSlurmdbV0041GetJobsRequest) ShowDuplicates(showDuplicates string) ApiSlurmdbV0041GetJobsRequest {
	r.showDuplicates = &showDuplicates
	return r
}

// Exclude job step details
func (r ApiSlurmdbV0041GetJobsRequest) SkipSteps(skipSteps string) ApiSlurmdbV0041GetJobsRequest {
	r.skipSteps = &skipSteps
	return r
}

// Do not truncate the time to usage_start and usage_end
func (r ApiSlurmdbV0041GetJobsRequest) DisableTruncateUsageTime(disableTruncateUsageTime string) ApiSlurmdbV0041GetJobsRequest {
	r.disableTruncateUsageTime = &disableTruncateUsageTime
	return r
}

// Include details on all hetjob components
func (r ApiSlurmdbV0041GetJobsRequest) WholeHetjob(wholeHetjob string) ApiSlurmdbV0041GetJobsRequest {
	r.wholeHetjob = &wholeHetjob
	return r
}

// Only show details on specified hetjob components
func (r ApiSlurmdbV0041GetJobsRequest) DisableWholeHetjob(disableWholeHetjob string) ApiSlurmdbV0041GetJobsRequest {
	r.disableWholeHetjob = &disableWholeHetjob
	return r
}

// Tell dbd not to wait for the result
func (r ApiSlurmdbV0041GetJobsRequest) DisableWaitForResult(disableWaitForResult string) ApiSlurmdbV0041GetJobsRequest {
	r.disableWaitForResult = &disableWaitForResult
	return r
}

// Use usage_time as the submit_time of the job
func (r ApiSlurmdbV0041GetJobsRequest) UsageTimeAsSubmitTime(usageTimeAsSubmitTime string) ApiSlurmdbV0041GetJobsRequest {
	r.usageTimeAsSubmitTime = &usageTimeAsSubmitTime
	return r
}

// Include job script
func (r ApiSlurmdbV0041GetJobsRequest) ShowBatchScript(showBatchScript string) ApiSlurmdbV0041GetJobsRequest {
	r.showBatchScript = &showBatchScript
	return r
}

// Include job environment
func (r ApiSlurmdbV0041GetJobsRequest) ShowJobEnvironment(showJobEnvironment string) ApiSlurmdbV0041GetJobsRequest {
	r.showJobEnvironment = &showJobEnvironment
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041GetJobsRequest) Format(format string) ApiSlurmdbV0041GetJobsRequest {
	r.format = &format
	return r
}

// CSV group list
func (r ApiSlurmdbV0041GetJobsRequest) Groups(groups string) ApiSlurmdbV0041GetJobsRequest {
	r.groups = &groups
	return r
}

// CSV job name list
func (r ApiSlurmdbV0041GetJobsRequest) JobName(jobName string) ApiSlurmdbV0041GetJobsRequest {
	r.jobName = &jobName
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0041GetJobsRequest) Partition(partition string) ApiSlurmdbV0041GetJobsRequest {
	r.partition = &partition
	return r
}

// CSV QOS name list
func (r ApiSlurmdbV0041GetJobsRequest) Qos(qos string) ApiSlurmdbV0041GetJobsRequest {
	r.qos = &qos
	return r
}

// CSV reason list
func (r ApiSlurmdbV0041GetJobsRequest) Reason(reason string) ApiSlurmdbV0041GetJobsRequest {
	r.reason = &reason
	return r
}

// CSV reservation name list
func (r ApiSlurmdbV0041GetJobsRequest) Reservation(reservation string) ApiSlurmdbV0041GetJobsRequest {
	r.reservation = &reservation
	return r
}

// CSV reservation ID list
func (r ApiSlurmdbV0041GetJobsRequest) ReservationId(reservationId string) ApiSlurmdbV0041GetJobsRequest {
	r.reservationId = &reservationId
	return r
}

// CSV state list
func (r ApiSlurmdbV0041GetJobsRequest) State(state string) ApiSlurmdbV0041GetJobsRequest {
	r.state = &state
	return r
}

// CSV step id list
func (r ApiSlurmdbV0041GetJobsRequest) Step(step string) ApiSlurmdbV0041GetJobsRequest {
	r.step = &step
	return r
}

// Usage end (UNIX timestamp)
func (r ApiSlurmdbV0041GetJobsRequest) EndTime(endTime string) ApiSlurmdbV0041GetJobsRequest {
	r.endTime = &endTime
	return r
}

// Usage start (UNIX timestamp)
func (r ApiSlurmdbV0041GetJobsRequest) StartTime(startTime string) ApiSlurmdbV0041GetJobsRequest {
	r.startTime = &startTime
	return r
}

// Ranged node string where jobs ran
func (r ApiSlurmdbV0041GetJobsRequest) Node(node string) ApiSlurmdbV0041GetJobsRequest {
	r.node = &node
	return r
}

// CSV user name list
func (r ApiSlurmdbV0041GetJobsRequest) Users(users string) ApiSlurmdbV0041GetJobsRequest {
	r.users = &users
	return r
}

// CSV wckey list
func (r ApiSlurmdbV0041GetJobsRequest) Wckey(wckey string) ApiSlurmdbV0041GetJobsRequest {
	r.wckey = &wckey
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) Execute() (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetJobsExecute(r)
}

/*
SlurmdbV0041GetJobs Get job list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetJobsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetJobs(ctx context.Context) ApiSlurmdbV0041GetJobsRequest {
	return ApiSlurmdbV0041GetJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetJobsExecute(r ApiSlurmdbV0041GetJobsRequest) (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.association != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "association", r.association, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.constraints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "constraints", r.constraints, "form", "")
	}
	if r.schedulerUnset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduler_unset", r.schedulerUnset, "form", "")
	}
	if r.scheduledOnSubmit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_on_submit", r.scheduledOnSubmit, "form", "")
	}
	if r.scheduledByMain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_main", r.scheduledByMain, "form", "")
	}
	if r.scheduledByBackfill != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_backfill", r.scheduledByBackfill, "form", "")
	}
	if r.jobStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_started", r.jobStarted, "form", "")
	}
	if r.exitCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exit_code", r.exitCode, "form", "")
	}
	if r.showDuplicates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_duplicates", r.showDuplicates, "form", "")
	}
	if r.skipSteps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_steps", r.skipSteps, "form", "")
	}
	if r.disableTruncateUsageTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_truncate_usage_time", r.disableTruncateUsageTime, "form", "")
	}
	if r.wholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whole_hetjob", r.wholeHetjob, "form", "")
	}
	if r.disableWholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_whole_hetjob", r.disableWholeHetjob, "form", "")
	}
	if r.disableWaitForResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_wait_for_result", r.disableWaitForResult, "form", "")
	}
	if r.usageTimeAsSubmitTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_time_as_submit_time", r.usageTimeAsSubmitTime, "form", "")
	}
	if r.showBatchScript != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_batch_script", r.showBatchScript, "form", "")
	}
	if r.showJobEnvironment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_job_environment", r.showJobEnvironment, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.groups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groups", r.groups, "form", "")
	}
	if r.jobName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_name", r.jobName, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.reason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reason", r.reason, "form", "")
	}
	if r.reservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation", r.reservation, "form", "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation_id", r.reservationId, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	}
	if r.node != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node", r.node, "form", "")
	}
	if r.users != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "users", r.users, "form", "")
	}
	if r.wckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wckey", r.wckey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdJobsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	description *string
	id *string
	format *string
	name *string
	preemptMode *string
	withDeleted *string
}

// CSV description list
func (r ApiSlurmdbV0041GetQosRequest) Description(description string) ApiSlurmdbV0041GetQosRequest {
	r.description = &description
	return r
}

// CSV QOS id list
func (r ApiSlurmdbV0041GetQosRequest) Id(id string) ApiSlurmdbV0041GetQosRequest {
	r.id = &id
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041GetQosRequest) Format(format string) ApiSlurmdbV0041GetQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r ApiSlurmdbV0041GetQosRequest) Name(name string) ApiSlurmdbV0041GetQosRequest {
	r.name = &name
	return r
}

// PreemptMode used when jobs in this QOS are preempted
func (r ApiSlurmdbV0041GetQosRequest) PreemptMode(preemptMode string) ApiSlurmdbV0041GetQosRequest {
	r.preemptMode = &preemptMode
	return r
}

// Include deleted QOS
func (r ApiSlurmdbV0041GetQosRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0041GetQosRequest) Execute() (*V0041OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetQosExecute(r)
}

/*
SlurmdbV0041GetQos Get QOS list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetQos(ctx context.Context) ApiSlurmdbV0041GetQosRequest {
	return ApiSlurmdbV0041GetQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0041GetQosExecute(r ApiSlurmdbV0041GetQosRequest) (*V0041OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/qos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetSingleQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	qos string
	withDeleted *string
}

// Query includes deleted QOS
func (r ApiSlurmdbV0041GetSingleQosRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetSingleQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0041GetSingleQosRequest) Execute() (*V0041OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetSingleQosExecute(r)
}

/*
SlurmdbV0041GetSingleQos Get QOS info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return ApiSlurmdbV0041GetSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetSingleQos(ctx context.Context, qos string) ApiSlurmdbV0041GetSingleQosRequest {
	return ApiSlurmdbV0041GetSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0041GetSingleQosExecute(r ApiSlurmdbV0041GetSingleQosRequest) (*V0041OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetTresRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
}

func (r ApiSlurmdbV0041GetTresRequest) Execute() (*V0041OpenapiTresResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetTresExecute(r)
}

/*
SlurmdbV0041GetTres Get TRES info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetTres(ctx context.Context) ApiSlurmdbV0041GetTresRequest {
	return ApiSlurmdbV0041GetTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiTresResp
func (a *SlurmdbAPIService) SlurmdbV0041GetTresExecute(r ApiSlurmdbV0041GetTresRequest) (*V0041OpenapiTresResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiTresResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/tres/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiTresResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetUserRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	name string
	withDeleted *string
	withAssocs *string
	withCoords *string
	withWckeys *string
}

// Include deleted users
func (r ApiSlurmdbV0041GetUserRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetUserRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include associations
func (r ApiSlurmdbV0041GetUserRequest) WithAssocs(withAssocs string) ApiSlurmdbV0041GetUserRequest {
	r.withAssocs = &withAssocs
	return r
}

// Include coordinators
func (r ApiSlurmdbV0041GetUserRequest) WithCoords(withCoords string) ApiSlurmdbV0041GetUserRequest {
	r.withCoords = &withCoords
	return r
}

// Include wckeys
func (r ApiSlurmdbV0041GetUserRequest) WithWckeys(withWckeys string) ApiSlurmdbV0041GetUserRequest {
	r.withWckeys = &withWckeys
	return r
}

func (r ApiSlurmdbV0041GetUserRequest) Execute() (*V0041OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetUserExecute(r)
}

/*
SlurmdbV0041GetUser Get user info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return ApiSlurmdbV0041GetUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetUser(ctx context.Context, name string) ApiSlurmdbV0041GetUserRequest {
	return ApiSlurmdbV0041GetUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0041OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0041GetUserExecute(r ApiSlurmdbV0041GetUserRequest) (*V0041OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiUsersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetUsersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	adminLevel *string
	defaultAccount *string
	defaultWckey *string
	withAssocs *string
	withCoords *string
	withDeleted *string
	withWckeys *string
	withoutDefaults *string
}

// Administrator level
func (r ApiSlurmdbV0041GetUsersRequest) AdminLevel(adminLevel string) ApiSlurmdbV0041GetUsersRequest {
	r.adminLevel = &adminLevel
	return r
}

// CSV default account list
func (r ApiSlurmdbV0041GetUsersRequest) DefaultAccount(defaultAccount string) ApiSlurmdbV0041GetUsersRequest {
	r.defaultAccount = &defaultAccount
	return r
}

// CSV default wckey list
func (r ApiSlurmdbV0041GetUsersRequest) DefaultWckey(defaultWckey string) ApiSlurmdbV0041GetUsersRequest {
	r.defaultWckey = &defaultWckey
	return r
}

// With associations
func (r ApiSlurmdbV0041GetUsersRequest) WithAssocs(withAssocs string) ApiSlurmdbV0041GetUsersRequest {
	r.withAssocs = &withAssocs
	return r
}

// With coordinators
func (r ApiSlurmdbV0041GetUsersRequest) WithCoords(withCoords string) ApiSlurmdbV0041GetUsersRequest {
	r.withCoords = &withCoords
	return r
}

// With deleted
func (r ApiSlurmdbV0041GetUsersRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetUsersRequest {
	r.withDeleted = &withDeleted
	return r
}

// With wckeys
func (r ApiSlurmdbV0041GetUsersRequest) WithWckeys(withWckeys string) ApiSlurmdbV0041GetUsersRequest {
	r.withWckeys = &withWckeys
	return r
}

// Exclude defaults
func (r ApiSlurmdbV0041GetUsersRequest) WithoutDefaults(withoutDefaults string) ApiSlurmdbV0041GetUsersRequest {
	r.withoutDefaults = &withoutDefaults
	return r
}

func (r ApiSlurmdbV0041GetUsersRequest) Execute() (*V0041OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetUsersExecute(r)
}

/*
SlurmdbV0041GetUsers Get user list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetUsers(ctx context.Context) ApiSlurmdbV0041GetUsersRequest {
	return ApiSlurmdbV0041GetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0041GetUsersExecute(r ApiSlurmdbV0041GetUsersRequest) (*V0041OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adminLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "admin_level", r.adminLevel, "form", "")
	}
	if r.defaultAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_account", r.defaultAccount, "form", "")
	}
	if r.defaultWckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_wckey", r.defaultWckey, "form", "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "form", "")
	}
	if r.withoutDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_defaults", r.withoutDefaults, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiUsersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetWckeyRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	id string
}

func (r ApiSlurmdbV0041GetWckeyRequest) Execute() (*V0041OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetWckeyExecute(r)
}

/*
SlurmdbV0041GetWckey Get wckey info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id wckey id
 @return ApiSlurmdbV0041GetWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetWckey(ctx context.Context, id string) ApiSlurmdbV0041GetWckeyRequest {
	return ApiSlurmdbV0041GetWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0041OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0041GetWckeyExecute(r ApiSlurmdbV0041GetWckeyRequest) (*V0041OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiWckeyResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetWckeysRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
}

// CSV cluster name list
func (r ApiSlurmdbV0041GetWckeysRequest) Cluster(cluster string) ApiSlurmdbV0041GetWckeysRequest {
	r.cluster = &cluster
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041GetWckeysRequest) Format(format string) ApiSlurmdbV0041GetWckeysRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0041GetWckeysRequest) Id(id string) ApiSlurmdbV0041GetWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r ApiSlurmdbV0041GetWckeysRequest) Name(name string) ApiSlurmdbV0041GetWckeysRequest {
	r.name = &name
	return r
}

// Only query defaults
func (r ApiSlurmdbV0041GetWckeysRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0041GetWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// Usage end (UNIX timestamp)
func (r ApiSlurmdbV0041GetWckeysRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041GetWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r ApiSlurmdbV0041GetWckeysRequest) UsageStart(usageStart string) ApiSlurmdbV0041GetWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0041GetWckeysRequest) User(user string) ApiSlurmdbV0041GetWckeysRequest {
	r.user = &user
	return r
}

// Include usage
func (r ApiSlurmdbV0041GetWckeysRequest) WithUsage(withUsage string) ApiSlurmdbV0041GetWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted wckeys
func (r ApiSlurmdbV0041GetWckeysRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0041GetWckeysRequest) Execute() (*V0041OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetWckeysExecute(r)
}

/*
SlurmdbV0041GetWckeys Get wckey list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetWckeys(ctx context.Context) ApiSlurmdbV0041GetWckeysRequest {
	return ApiSlurmdbV0041GetWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0041GetWckeysExecute(r ApiSlurmdbV0041GetWckeysRequest) (*V0041OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/wckeys/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiWckeyResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostAccountsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0041OpenapiAccountsResp *V0041OpenapiAccountsResp
}

// Description of accounts to update/create
func (r ApiSlurmdbV0041PostAccountsRequest) V0041OpenapiAccountsResp(v0041OpenapiAccountsResp V0041OpenapiAccountsResp) ApiSlurmdbV0041PostAccountsRequest {
	r.v0041OpenapiAccountsResp = &v0041OpenapiAccountsResp
	return r
}

func (r ApiSlurmdbV0041PostAccountsRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostAccountsExecute(r)
}

/*
SlurmdbV0041PostAccounts Add/update list of accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostAccounts(ctx context.Context) ApiSlurmdbV0041PostAccountsRequest {
	return ApiSlurmdbV0041PostAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostAccountsExecute(r ApiSlurmdbV0041PostAccountsRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/accounts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiAccountsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostAccountsAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	slurmdbV0041PostAccountsAssociationRequest *SlurmdbV0041PostAccountsAssociationRequest
}

// Add list of accounts with conditional association
func (r ApiSlurmdbV0041PostAccountsAssociationRequest) SlurmdbV0041PostAccountsAssociationRequest(slurmdbV0041PostAccountsAssociationRequest SlurmdbV0041PostAccountsAssociationRequest) ApiSlurmdbV0041PostAccountsAssociationRequest {
	r.slurmdbV0041PostAccountsAssociationRequest = &slurmdbV0041PostAccountsAssociationRequest
	return r
}

func (r ApiSlurmdbV0041PostAccountsAssociationRequest) Execute() (*SlurmdbV0041PostAccountsAssociation200Response, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostAccountsAssociationExecute(r)
}

/*
SlurmdbV0041PostAccountsAssociation Add accounts with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostAccountsAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostAccountsAssociation(ctx context.Context) ApiSlurmdbV0041PostAccountsAssociationRequest {
	return ApiSlurmdbV0041PostAccountsAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SlurmdbV0041PostAccountsAssociation200Response
func (a *SlurmdbAPIService) SlurmdbV0041PostAccountsAssociationExecute(r ApiSlurmdbV0041PostAccountsAssociationRequest) (*SlurmdbV0041PostAccountsAssociation200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SlurmdbV0041PostAccountsAssociation200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostAccountsAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/accounts_association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.slurmdbV0041PostAccountsAssociationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v SlurmdbV0041PostAccountsAssociation200Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostAssociationsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0041OpenapiAssocsResp *V0041OpenapiAssocsResp
}

// Job description
func (r ApiSlurmdbV0041PostAssociationsRequest) V0041OpenapiAssocsResp(v0041OpenapiAssocsResp V0041OpenapiAssocsResp) ApiSlurmdbV0041PostAssociationsRequest {
	r.v0041OpenapiAssocsResp = &v0041OpenapiAssocsResp
	return r
}

func (r ApiSlurmdbV0041PostAssociationsRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostAssociationsExecute(r)
}

/*
SlurmdbV0041PostAssociations Set associations info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostAssociations(ctx context.Context) ApiSlurmdbV0041PostAssociationsRequest {
	return ApiSlurmdbV0041PostAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostAssociationsExecute(r ApiSlurmdbV0041PostAssociationsRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiAssocsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostClustersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	updateTime *string
	v0041OpenapiClustersResp *V0041OpenapiClustersResp
}

// Filter reservations since update timestamp
func (r ApiSlurmdbV0041PostClustersRequest) UpdateTime(updateTime string) ApiSlurmdbV0041PostClustersRequest {
	r.updateTime = &updateTime
	return r
}

// Cluster add or update descriptions
func (r ApiSlurmdbV0041PostClustersRequest) V0041OpenapiClustersResp(v0041OpenapiClustersResp V0041OpenapiClustersResp) ApiSlurmdbV0041PostClustersRequest {
	r.v0041OpenapiClustersResp = &v0041OpenapiClustersResp
	return r
}

func (r ApiSlurmdbV0041PostClustersRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostClustersExecute(r)
}

/*
SlurmdbV0041PostClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostClusters(ctx context.Context) ApiSlurmdbV0041PostClustersRequest {
	return ApiSlurmdbV0041PostClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostClustersExecute(r ApiSlurmdbV0041PostClustersRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiClustersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostConfigRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0041OpenapiSlurmdbdConfigResp *V0041OpenapiSlurmdbdConfigResp
}

// Add or update config
func (r ApiSlurmdbV0041PostConfigRequest) V0041OpenapiSlurmdbdConfigResp(v0041OpenapiSlurmdbdConfigResp V0041OpenapiSlurmdbdConfigResp) ApiSlurmdbV0041PostConfigRequest {
	r.v0041OpenapiSlurmdbdConfigResp = &v0041OpenapiSlurmdbdConfigResp
	return r
}

func (r ApiSlurmdbV0041PostConfigRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostConfigExecute(r)
}

/*
SlurmdbV0041PostConfig Load all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostConfig(ctx context.Context) ApiSlurmdbV0041PostConfigRequest {
	return ApiSlurmdbV0041PostConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostConfigExecute(r ApiSlurmdbV0041PostConfigRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiSlurmdbdConfigResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	description *string
	id *string
	format *string
	name *string
	preemptMode *string
	withDeleted *string
	v0041OpenapiSlurmdbdQosResp *V0041OpenapiSlurmdbdQosResp
}

// CSV description list
func (r ApiSlurmdbV0041PostQosRequest) Description(description string) ApiSlurmdbV0041PostQosRequest {
	r.description = &description
	return r
}

// CSV QOS id list
func (r ApiSlurmdbV0041PostQosRequest) Id(id string) ApiSlurmdbV0041PostQosRequest {
	r.id = &id
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041PostQosRequest) Format(format string) ApiSlurmdbV0041PostQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r ApiSlurmdbV0041PostQosRequest) Name(name string) ApiSlurmdbV0041PostQosRequest {
	r.name = &name
	return r
}

// PreemptMode used when jobs in this QOS are preempted
func (r ApiSlurmdbV0041PostQosRequest) PreemptMode(preemptMode string) ApiSlurmdbV0041PostQosRequest {
	r.preemptMode = &preemptMode
	return r
}

// Include deleted QOS
func (r ApiSlurmdbV0041PostQosRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041PostQosRequest {
	r.withDeleted = &withDeleted
	return r
}

// Description of QOS to add or update
func (r ApiSlurmdbV0041PostQosRequest) V0041OpenapiSlurmdbdQosResp(v0041OpenapiSlurmdbdQosResp V0041OpenapiSlurmdbdQosResp) ApiSlurmdbV0041PostQosRequest {
	r.v0041OpenapiSlurmdbdQosResp = &v0041OpenapiSlurmdbdQosResp
	return r
}

func (r ApiSlurmdbV0041PostQosRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostQosExecute(r)
}

/*
SlurmdbV0041PostQos Add or update QOSs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostQos(ctx context.Context) ApiSlurmdbV0041PostQosRequest {
	return ApiSlurmdbV0041PostQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostQosExecute(r ApiSlurmdbV0041PostQosRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/qos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiSlurmdbdQosResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostTresRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0041OpenapiTresResp *V0041OpenapiTresResp
}

// TRES descriptions. Only works in developer mode.
func (r ApiSlurmdbV0041PostTresRequest) V0041OpenapiTresResp(v0041OpenapiTresResp V0041OpenapiTresResp) ApiSlurmdbV0041PostTresRequest {
	r.v0041OpenapiTresResp = &v0041OpenapiTresResp
	return r
}

func (r ApiSlurmdbV0041PostTresRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostTresExecute(r)
}

/*
SlurmdbV0041PostTres Add TRES

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostTres(ctx context.Context) ApiSlurmdbV0041PostTresRequest {
	return ApiSlurmdbV0041PostTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostTresExecute(r ApiSlurmdbV0041PostTresRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/tres/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiTresResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostUsersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0041OpenapiUsersResp *V0041OpenapiUsersResp
}

// add or update user
func (r ApiSlurmdbV0041PostUsersRequest) V0041OpenapiUsersResp(v0041OpenapiUsersResp V0041OpenapiUsersResp) ApiSlurmdbV0041PostUsersRequest {
	r.v0041OpenapiUsersResp = &v0041OpenapiUsersResp
	return r
}

func (r ApiSlurmdbV0041PostUsersRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostUsersExecute(r)
}

/*
SlurmdbV0041PostUsers Update users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostUsers(ctx context.Context) ApiSlurmdbV0041PostUsersRequest {
	return ApiSlurmdbV0041PostUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostUsersExecute(r ApiSlurmdbV0041PostUsersRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiUsersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostUsersAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	updateTime *string
	flags *string
	slurmdbV0041PostUsersAssociationRequest *SlurmdbV0041PostUsersAssociationRequest
}

// Filter partitions since update timestamp
func (r ApiSlurmdbV0041PostUsersAssociationRequest) UpdateTime(updateTime string) ApiSlurmdbV0041PostUsersAssociationRequest {
	r.updateTime = &updateTime
	return r
}

// Query flags
func (r ApiSlurmdbV0041PostUsersAssociationRequest) Flags(flags string) ApiSlurmdbV0041PostUsersAssociationRequest {
	r.flags = &flags
	return r
}

// Create users with conditional association
func (r ApiSlurmdbV0041PostUsersAssociationRequest) SlurmdbV0041PostUsersAssociationRequest(slurmdbV0041PostUsersAssociationRequest SlurmdbV0041PostUsersAssociationRequest) ApiSlurmdbV0041PostUsersAssociationRequest {
	r.slurmdbV0041PostUsersAssociationRequest = &slurmdbV0041PostUsersAssociationRequest
	return r
}

func (r ApiSlurmdbV0041PostUsersAssociationRequest) Execute() (*SlurmdbV0041PostUsersAssociation200Response, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostUsersAssociationExecute(r)
}

/*
SlurmdbV0041PostUsersAssociation Add users with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostUsersAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostUsersAssociation(ctx context.Context) ApiSlurmdbV0041PostUsersAssociationRequest {
	return ApiSlurmdbV0041PostUsersAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SlurmdbV0041PostUsersAssociation200Response
func (a *SlurmdbAPIService) SlurmdbV0041PostUsersAssociationExecute(r ApiSlurmdbV0041PostUsersAssociationRequest) (*SlurmdbV0041PostUsersAssociation200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SlurmdbV0041PostUsersAssociation200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostUsersAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/users_association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "form", "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.slurmdbV0041PostUsersAssociationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v SlurmdbV0041PostUsersAssociation200Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostWckeysRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	v0041OpenapiWckeyResp *V0041OpenapiWckeyResp
}

// CSV cluster name list
func (r ApiSlurmdbV0041PostWckeysRequest) Cluster(cluster string) ApiSlurmdbV0041PostWckeysRequest {
	r.cluster = &cluster
	return r
}

// Ignored; process JSON manually to control output format
func (r ApiSlurmdbV0041PostWckeysRequest) Format(format string) ApiSlurmdbV0041PostWckeysRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0041PostWckeysRequest) Id(id string) ApiSlurmdbV0041PostWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r ApiSlurmdbV0041PostWckeysRequest) Name(name string) ApiSlurmdbV0041PostWckeysRequest {
	r.name = &name
	return r
}

// Only query defaults
func (r ApiSlurmdbV0041PostWckeysRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0041PostWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// Usage end (UNIX timestamp)
func (r ApiSlurmdbV0041PostWckeysRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041PostWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r ApiSlurmdbV0041PostWckeysRequest) UsageStart(usageStart string) ApiSlurmdbV0041PostWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0041PostWckeysRequest) User(user string) ApiSlurmdbV0041PostWckeysRequest {
	r.user = &user
	return r
}

// Include usage
func (r ApiSlurmdbV0041PostWckeysRequest) WithUsage(withUsage string) ApiSlurmdbV0041PostWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted wckeys
func (r ApiSlurmdbV0041PostWckeysRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041PostWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

// wckeys description
func (r ApiSlurmdbV0041PostWckeysRequest) V0041OpenapiWckeyResp(v0041OpenapiWckeyResp V0041OpenapiWckeyResp) ApiSlurmdbV0041PostWckeysRequest {
	r.v0041OpenapiWckeyResp = &v0041OpenapiWckeyResp
	return r
}

func (r ApiSlurmdbV0041PostWckeysRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostWckeysExecute(r)
}

/*
SlurmdbV0041PostWckeys Add or update wckeys

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostWckeys(ctx context.Context) ApiSlurmdbV0041PostWckeysRequest {
	return ApiSlurmdbV0041PostWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostWckeysExecute(r ApiSlurmdbV0041PostWckeysRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/wckeys/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiWckeyResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
